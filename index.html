<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Asteroids</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh;
    user-select: none; -webkit-user-select: none; overscroll-behavior: none;
  }
  canvas { display: block; touch-action: none; position: fixed; top: 0; left: 0; }

  /* Touch controls */
  .touch-btn {
    display: none;
    position: fixed;
    z-index: 10;
    border: 2px solid rgba(255,255,255,0.5);
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.7);
    font-family: "Courier New", monospace;
    font-weight: bold;
    text-align: center;
    pointer-events: auto;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
  }
  .touch-btn:active { background: rgba(255,255,255,0.25); }

  .touch-visible .touch-btn.game-btn { display: flex; align-items: center; justify-content: center; }
  .touch-visible.state-menu .touch-btn.menu-btn { display: flex; align-items: center; justify-content: center; }
  .touch-visible.state-gameover .touch-btn.gameover-btn { display: flex; align-items: center; justify-content: center; }
  .touch-visible.state-menu .touch-btn.game-btn { display: none; }
  .touch-visible.state-gameover .touch-btn.game-btn { display: none; }

  /* Game control buttons */
  #btn-left, #btn-right {
    bottom: 30px; width: 70px; height: 70px; border-radius: 50%; font-size: 24px;
  }
  #btn-left { left: 20px; }
  #btn-right { left: 100px; }
  #btn-thrust {
    bottom: 110px; left: 45px; width: 80px; height: 56px; border-radius: 12px; font-size: 14px;
  }
  #btn-fire {
    bottom: 30px; right: 20px; width: 90px; height: 90px; border-radius: 50%; font-size: 16px;
    border-color: rgba(255,255,255,0.6);
  }
  #btn-hyper {
    bottom: 130px; right: 30px; width: 70px; height: 50px; border-radius: 12px; font-size: 11px;
  }

  /* Menu buttons */
  #btn-classic, #btn-starwars {
    width: 260px; height: 52px; border-radius: 10px; font-size: 18px; left: 50%; transform: translateX(-50%);
  }
  #btn-classic { top: calc(50% + 40px); }
  #btn-starwars { top: calc(50% + 100px); }

  /* Game over button */
  #btn-enter {
    width: 280px; height: 52px; border-radius: 10px; font-size: 16px;
    left: 50%; transform: translateX(-50%); top: calc(50% + 50px);
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- Touch controls (shown only on touch devices) -->
<button id="btn-left" class="touch-btn game-btn">&larr;</button>
<button id="btn-right" class="touch-btn game-btn">&rarr;</button>
<button id="btn-thrust" class="touch-btn game-btn">THRUST</button>
<button id="btn-fire" class="touch-btn game-btn">FIRE</button>
<button id="btn-hyper" class="touch-btn game-btn">HYPER</button>

<button id="btn-classic" class="touch-btn menu-btn">1 CLASSIC 1979</button>
<button id="btn-starwars" class="touch-btn menu-btn">2 STAR WARS</button>

<button id="btn-enter" class="touch-btn gameover-btn">CONTINUE</button>

<script>
// ============================================================
// ASTEROIDS - 1979 Arcade Clone (Classic + Star Wars Theme)
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

let WIDTH = window.innerWidth;
let HEIGHT = window.innerHeight;

function resizeCanvas() {
  WIDTH = window.innerWidth;
  HEIGHT = window.innerHeight;
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
}
resizeCanvas();
window.addEventListener('resize', () => { resizeCanvas(); initStars(); });

// ============================================================
// THEME
// ============================================================
let theme = 'starwars'; // 'classic' or 'starwars'

// ============================================================
// CLASSIC SHAPES
// ============================================================
const CLASSIC_SHIP = [
  [0, -15], [10, 10], [6, 7], [-6, 7], [-10, 10]
];
const CLASSIC_THRUST = [
  [-6, 7], [0, 17], [6, 7]
];

// ============================================================
// STAR WARS SHAPES - Millennium Falcon
// ============================================================
const FALCON_SHIP = [
  [-2, -10], [-4, -16], [-6, -16],
  [-9, -10], [-12, -4], [-13, 2], [-11, 7],
  [-7, 11], [0, 12], [7, 11],
  [11, 7], [12, 2],
  [14, 1], [17, 0], [14, -1],
  [12, -4], [9, -10],
  [6, -16], [4, -16],
  [2, -10],
];
const FALCON_DISH = { x: -3, y: 0, r: 3.5 };
const FALCON_CORRIDOR = [[-2, -10], [-2, 4], [2, 4], [2, -10]];
const FALCON_THRUST = [
  [-7, 11], [0, 20], [7, 11]
];

// ============================================================
// STAR WARS SHAPES - TIE Fighter
// ============================================================
const TIE_COCKPIT = [];
for (let i = 0; i < 8; i++) {
  const ca = (i / 8) * Math.PI * 2;
  TIE_COCKPIT.push([Math.cos(ca) * 0.25, Math.sin(ca) * 0.25]);
}
const TIE_VIEWPORT = [];
for (let i = 0; i < 6; i++) {
  const ca = (i / 6) * Math.PI * 2 - Math.PI / 6;
  TIE_VIEWPORT.push([Math.cos(ca) * 0.14, Math.sin(ca) * 0.14]);
}
const TIE_LEFT_WING = [
  [-0.5, -0.95], [-0.95, -0.7], [-0.95, 0.7], [-0.5, 0.95],
  [-0.4, 0.7], [-0.4, -0.7]
];
const TIE_RIGHT_WING = [
  [0.5, -0.95], [0.4, -0.7], [0.4, 0.7], [0.5, 0.95],
  [0.95, 0.7], [0.95, -0.7]
];
const TIE_STRUT_L1 = [[-0.25, -0.06], [-0.4, -0.06]];
const TIE_STRUT_L2 = [[-0.25, 0.06], [-0.4, 0.06]];
const TIE_STRUT_R1 = [[0.25, -0.06], [0.4, -0.06]];
const TIE_STRUT_R2 = [[0.25, 0.06], [0.4, 0.06]];
const TIE_LW_BRACE1 = [[-0.42, -0.35], [-0.93, -0.35]];
const TIE_LW_BRACE2 = [[-0.42, 0.0], [-0.93, 0.0]];
const TIE_LW_BRACE3 = [[-0.42, 0.35], [-0.93, 0.35]];
const TIE_RW_BRACE1 = [[0.42, -0.35], [0.93, -0.35]];
const TIE_RW_BRACE2 = [[0.42, 0.0], [0.93, 0.0]];
const TIE_RW_BRACE3 = [[0.42, 0.35], [0.93, 0.35]];

// ============================================================
// AUDIO
// ============================================================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);

  switch (type) {
    case 'fire':
      if (theme === 'starwars') {
        // Falcon cannon chirp: bright high-pitched double-pulse
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(3800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.06);
        osc.frequency.setValueAtTime(3500, now + 0.07);
        osc.frequency.exponentialRampToValueAtTime(900, now + 0.13);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.setValueAtTime(0.03, now + 0.06);
        gain.gain.setValueAtTime(0.10, now + 0.07);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.14);
        osc.start(now); osc.stop(now + 0.14);
        // Add a metallic ring on top
        const chirpOsc = audioCtx.createOscillator();
        const chirpGain = audioCtx.createGain();
        chirpOsc.type = 'square';
        chirpOsc.frequency.setValueAtTime(5000, now);
        chirpOsc.frequency.exponentialRampToValueAtTime(1800, now + 0.08);
        chirpGain.gain.setValueAtTime(0.06, now);
        chirpGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        chirpOsc.connect(chirpGain); chirpGain.connect(audioCtx.destination);
        chirpOsc.start(now); chirpOsc.stop(now + 0.1);
      } else {
        // Classic deep analog fire
        osc.type = 'square';
        osc.frequency.setValueAtTime(880, now);
        osc.frequency.exponentialRampToValueAtTime(110, now + 0.15);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
      }
      break;
    case 'thrust':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(60, now);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc.start(now); osc.stop(now + 0.12);
      break;
    case 'explode_big': {
      if (theme === 'starwars') {
        // TIE Fighter screech: high-pitched descending shriek + noise burst
        const duration = 0.8;
        // Screech oscillator (the iconic TIE whine)
        const screech = audioCtx.createOscillator();
        screech.type = 'sawtooth';
        screech.frequency.setValueAtTime(3200, now);
        screech.frequency.exponentialRampToValueAtTime(600, now + 0.3);
        screech.frequency.exponentialRampToValueAtTime(200, now + duration);
        const sGain = audioCtx.createGain();
        sGain.gain.setValueAtTime(0.18, now);
        sGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        const sFilter = audioCtx.createBiquadFilter();
        sFilter.type = 'bandpass';
        sFilter.frequency.setValueAtTime(2500, now);
        sFilter.frequency.exponentialRampToValueAtTime(400, now + duration);
        sFilter.Q.setValueAtTime(3.0, now);
        screech.connect(sFilter); sFilter.connect(sGain); sGain.connect(audioCtx.destination);
        screech.start(now); screech.stop(now + duration);
        // Second harmonic screech layer
        const screech2 = audioCtx.createOscillator();
        screech2.type = 'square';
        screech2.frequency.setValueAtTime(4800, now);
        screech2.frequency.exponentialRampToValueAtTime(300, now + 0.4);
        const s2Gain = audioCtx.createGain();
        s2Gain.gain.setValueAtTime(0.08, now);
        s2Gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        screech2.connect(s2Gain); s2Gain.connect(audioCtx.destination);
        screech2.start(now); screech2.stop(now + 0.5);
        // Noise crunch underneath
        const bs = audioCtx.sampleRate * duration;
        const bf = audioCtx.createBuffer(1, bs, audioCtx.sampleRate);
        const d = bf.getChannelData(0);
        for (let i = 0; i < bs; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / bs);
        const nSrc = audioCtx.createBufferSource(); nSrc.buffer = bf;
        const nFilt = audioCtx.createBiquadFilter();
        nFilt.type = 'highpass'; nFilt.frequency.setValueAtTime(800, now);
        nFilt.frequency.exponentialRampToValueAtTime(100, now + duration);
        const nG = audioCtx.createGain();
        nG.gain.setValueAtTime(0.15, now);
        nG.gain.exponentialRampToValueAtTime(0.001, now + duration);
        nSrc.connect(nFilt); nFilt.connect(nG); nG.connect(audioCtx.destination);
        nSrc.start(now); nSrc.stop(now + duration);
      } else {
        // Classic deep brown noise explosion
        const duration = 1.0;
        const bufSize = audioCtx.sampleRate * duration;
        const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        let brown = 0;
        for (let i = 0; i < bufSize; i++) {
          brown += (Math.random() * 2 - 1) * 0.1;
          brown = Math.max(-1, Math.min(1, brown));
          data[i] = brown;
        }
        const noise = audioCtx.createBufferSource(); noise.buffer = buf;
        const lpf = audioCtx.createBiquadFilter();
        lpf.type = 'lowpass';
        lpf.frequency.setValueAtTime(150, now);
        lpf.frequency.exponentialRampToValueAtTime(40, now + duration);
        lpf.Q.setValueAtTime(1.0, now);
        const subOsc = audioCtx.createOscillator();
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(150, now);
        subOsc.frequency.exponentialRampToValueAtTime(40, now + duration);
        const subGain = audioCtx.createGain();
        subGain.gain.setValueAtTime(0.35, now);
        subGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        subOsc.connect(subGain); subGain.connect(audioCtx.destination);
        subOsc.start(now); subOsc.stop(now + duration);
        const nGain = audioCtx.createGain();
        noise.connect(lpf); lpf.connect(nGain); nGain.connect(audioCtx.destination);
        nGain.gain.setValueAtTime(0.5, now);
        nGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        noise.start(now); noise.stop(now + duration);
      }
      return;
    }
    case 'explode_small': {
      if (theme === 'starwars') {
        // Smaller TIE screech: shorter, higher pitch
        const duration = 0.4;
        const screech = audioCtx.createOscillator();
        screech.type = 'sawtooth';
        screech.frequency.setValueAtTime(4000, now);
        screech.frequency.exponentialRampToValueAtTime(800, now + duration);
        const sGain = audioCtx.createGain();
        sGain.gain.setValueAtTime(0.12, now);
        sGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        const sFilter = audioCtx.createBiquadFilter();
        sFilter.type = 'bandpass';
        sFilter.frequency.setValueAtTime(3000, now);
        sFilter.frequency.exponentialRampToValueAtTime(600, now + duration);
        sFilter.Q.setValueAtTime(2.5, now);
        screech.connect(sFilter); sFilter.connect(sGain); sGain.connect(audioCtx.destination);
        screech.start(now); screech.stop(now + duration);
        // Noise pop
        const bs = audioCtx.sampleRate * 0.2;
        const bf = audioCtx.createBuffer(1, bs, audioCtx.sampleRate);
        const d = bf.getChannelData(0);
        for (let i = 0; i < bs; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / bs);
        const nSrc = audioCtx.createBufferSource(); nSrc.buffer = bf;
        const nG = audioCtx.createGain();
        nG.gain.setValueAtTime(0.1, now);
        nG.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        nSrc.connect(nG); nG.connect(audioCtx.destination);
        nSrc.start(now); nSrc.stop(now + 0.2);
      } else {
        // Classic smaller explosion
        const duration = 0.5;
        const bs2 = audioCtx.sampleRate * duration;
        const bf2 = audioCtx.createBuffer(1, bs2, audioCtx.sampleRate);
        const d2 = bf2.getChannelData(0);
        let br2 = 0;
        for (let i = 0; i < bs2; i++) {
          br2 += (Math.random() * 2 - 1) * 0.1;
          br2 = Math.max(-1, Math.min(1, br2));
          d2[i] = br2;
        }
        const n2 = audioCtx.createBufferSource(); n2.buffer = bf2;
        const lpf2 = audioCtx.createBiquadFilter();
        lpf2.type = 'lowpass';
        lpf2.frequency.setValueAtTime(200, now);
        lpf2.frequency.exponentialRampToValueAtTime(60, now + duration);
        const subOsc2 = audioCtx.createOscillator();
        subOsc2.type = 'sine';
        subOsc2.frequency.setValueAtTime(180, now);
        subOsc2.frequency.exponentialRampToValueAtTime(50, now + duration);
        const subGain2 = audioCtx.createGain();
        subGain2.gain.setValueAtTime(0.2, now);
        subGain2.gain.exponentialRampToValueAtTime(0.001, now + duration);
        subOsc2.connect(subGain2); subGain2.connect(audioCtx.destination);
        subOsc2.start(now); subOsc2.stop(now + duration);
        const g2 = audioCtx.createGain();
        n2.connect(lpf2); lpf2.connect(g2); g2.connect(audioCtx.destination);
        g2.gain.setValueAtTime(0.35, now);
        g2.gain.exponentialRampToValueAtTime(0.001, now + duration);
        n2.start(now); n2.stop(now + duration);
      }
      return;
    }
    case 'explode_player': {
      if (theme === 'starwars') {
        // Falcon destruction: long screech descending into deep rumble
        const duration = 1.5;
        // Initial high screech
        const screech = audioCtx.createOscillator();
        screech.type = 'sawtooth';
        screech.frequency.setValueAtTime(2800, now);
        screech.frequency.exponentialRampToValueAtTime(100, now + 0.8);
        screech.frequency.exponentialRampToValueAtTime(40, now + duration);
        const sGain = audioCtx.createGain();
        sGain.gain.setValueAtTime(0.2, now);
        sGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        const sFilter = audioCtx.createBiquadFilter();
        sFilter.type = 'bandpass';
        sFilter.frequency.setValueAtTime(2000, now);
        sFilter.frequency.exponentialRampToValueAtTime(80, now + duration);
        sFilter.Q.setValueAtTime(2.0, now);
        screech.connect(sFilter); sFilter.connect(sGain); sGain.connect(audioCtx.destination);
        screech.start(now); screech.stop(now + duration);
        // Deep sub-bass rumble underneath
        const sub = audioCtx.createOscillator();
        sub.type = 'sine';
        sub.frequency.setValueAtTime(80, now + 0.2);
        sub.frequency.exponentialRampToValueAtTime(25, now + duration);
        const subG = audioCtx.createGain();
        subG.gain.setValueAtTime(0.001, now);
        subG.gain.linearRampToValueAtTime(0.4, now + 0.3);
        subG.gain.exponentialRampToValueAtTime(0.001, now + duration);
        sub.connect(subG); subG.connect(audioCtx.destination);
        sub.start(now); sub.stop(now + duration);
        // Wide noise burst
        const bs = audioCtx.sampleRate * duration;
        const bf = audioCtx.createBuffer(1, bs, audioCtx.sampleRate);
        const d = bf.getChannelData(0);
        let brown = 0;
        for (let i = 0; i < bs; i++) {
          brown += (Math.random() * 2 - 1) * 0.12;
          brown = Math.max(-1, Math.min(1, brown));
          d[i] = brown;
        }
        const nSrc = audioCtx.createBufferSource(); nSrc.buffer = bf;
        const nG = audioCtx.createGain();
        nG.gain.setValueAtTime(0.35, now);
        nG.gain.exponentialRampToValueAtTime(0.001, now + duration);
        nSrc.connect(nG); nG.connect(audioCtx.destination);
        nSrc.start(now); nSrc.stop(now + duration);
      } else {
        // Classic deep player explosion
        const duration = 1.5;
        const bs3 = audioCtx.sampleRate * duration;
        const bf3 = audioCtx.createBuffer(1, bs3, audioCtx.sampleRate);
        const d3 = bf3.getChannelData(0);
        let br3 = 0;
        for (let i = 0; i < bs3; i++) {
          br3 += (Math.random() * 2 - 1) * 0.1;
          br3 = Math.max(-1, Math.min(1, br3));
          d3[i] = br3;
        }
        const n3 = audioCtx.createBufferSource(); n3.buffer = bf3;
        const lpf3 = audioCtx.createBiquadFilter();
        lpf3.type = 'lowpass';
        lpf3.frequency.setValueAtTime(180, now);
        lpf3.frequency.exponentialRampToValueAtTime(30, now + duration);
        lpf3.Q.setValueAtTime(1.2, now);
        const subOsc3 = audioCtx.createOscillator();
        subOsc3.type = 'sine';
        subOsc3.frequency.setValueAtTime(150, now);
        subOsc3.frequency.exponentialRampToValueAtTime(25, now + duration);
        const subGain3 = audioCtx.createGain();
        subGain3.gain.setValueAtTime(0.45, now);
        subGain3.gain.exponentialRampToValueAtTime(0.001, now + duration);
        subOsc3.connect(subGain3); subGain3.connect(audioCtx.destination);
        subOsc3.start(now); subOsc3.stop(now + duration);
        const g3 = audioCtx.createGain();
        n3.connect(lpf3); lpf3.connect(g3); g3.connect(audioCtx.destination);
        g3.gain.setValueAtTime(0.6, now);
        g3.gain.exponentialRampToValueAtTime(0.001, now + duration);
        n3.start(now); n3.stop(now + duration);
      }
      return;
    }
    case 'hyperspace': {
      osc.type = 'sine';
      osc.frequency.setValueAtTime(200, now);
      osc.frequency.exponentialRampToValueAtTime(2000, now + 0.15);
      osc.frequency.exponentialRampToValueAtTime(100, now + 0.4);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      osc.start(now); osc.stop(now + 0.4);
      break;
    }
    case 'ufo_big':
      osc.type = 'square';
      osc.frequency.setValueAtTime(120, now);
      for (let i = 0; i < 10; i++) {
        osc.frequency.setValueAtTime(120, now + i * 0.1);
        osc.frequency.setValueAtTime(150, now + i * 0.1 + 0.05);
      }
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.setValueAtTime(0.1, now + 0.95);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
      osc.start(now); osc.stop(now + 1.0);
      break;
    case 'ufo_small':
      osc.type = 'square';
      osc.frequency.setValueAtTime(400, now);
      for (let i = 0; i < 20; i++) {
        osc.frequency.setValueAtTime(400, now + i * 0.05);
        osc.frequency.setValueAtTime(450, now + i * 0.05 + 0.025);
      }
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.setValueAtTime(0.08, now + 0.95);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
      osc.start(now); osc.stop(now + 1.0);
      break;
    case 'beat1':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(55, now);
      gain.gain.setValueAtTime(0.25, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      osc.start(now); osc.stop(now + 0.18);
      break;
    case 'beat2':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(46, now);
      gain.gain.setValueAtTime(0.25, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      osc.start(now); osc.stop(now + 0.18);
      break;
    case 'extra_life':
      osc.type = 'square';
      osc.frequency.setValueAtTime(440, now);
      osc.frequency.setValueAtTime(660, now + 0.1);
      osc.frequency.setValueAtTime(880, now + 0.2);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.setValueAtTime(0.15, now + 0.25);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      osc.start(now); osc.stop(now + 0.3);
      break;
  }
}

// ============================================================
// HEARTBEAT
// ============================================================
let beatTimer = 0;
let beatInterval = 1.0;
let beatToggle = false;

function updateBeat(dt) {
  if (state !== 'playing') return;
  beatTimer += dt;
  if (beatTimer >= beatInterval) {
    beatTimer = 0;
    playSound(beatToggle ? 'beat1' : 'beat2');
    beatToggle = !beatToggle;
  }
  const totalAsteroids = asteroids.length;
  if (totalAsteroids <= 2) beatInterval = 0.2;
  else if (totalAsteroids <= 4) beatInterval = 0.3;
  else if (totalAsteroids <= 6) beatInterval = 0.4;
  else if (totalAsteroids <= 8) beatInterval = 0.55;
  else if (totalAsteroids <= 10) beatInterval = 0.7;
  else beatInterval = 0.85;
}

// ============================================================
// PARALLAX STAR BACKGROUND
// ============================================================
let starsFar = [];   // distant layer (slow)
let starsNear = [];  // near layer (faster)
let camX = 0, camY = 0; // cumulative camera offset from ship movement

function initStars() {
  starsFar = [];
  starsNear = [];
  for (let i = 0; i < 120; i++) {
    starsFar.push({
      x: Math.random() * WIDTH,
      y: Math.random() * HEIGHT,
      brightness: 0.2 + Math.random() * 0.3,
      size: 0.5 + Math.random() * 0.5
    });
  }
  for (let i = 0; i < 60; i++) {
    starsNear.push({
      x: Math.random() * WIDTH,
      y: Math.random() * HEIGHT,
      brightness: 0.4 + Math.random() * 0.4,
      size: 1.0 + Math.random() * 1.0
    });
  }
}
initStars();

function drawStars() {
  // Far stars move at 0.05x ship velocity, near at 0.15x
  for (const s of starsFar) {
    const sx = ((s.x - camX * 0.05) % WIDTH + WIDTH) % WIDTH;
    const sy = ((s.y - camY * 0.05) % HEIGHT + HEIGHT) % HEIGHT;
    ctx.fillStyle = `rgba(255,255,255,${s.brightness})`;
    ctx.fillRect(sx, sy, s.size, s.size);
  }
  for (const s of starsNear) {
    const sx = ((s.x - camX * 0.15) % WIDTH + WIDTH) % WIDTH;
    const sy = ((s.y - camY * 0.15) % HEIGHT + HEIGHT) % HEIGHT;
    ctx.fillStyle = `rgba(255,255,255,${s.brightness})`;
    ctx.fillRect(sx, sy, s.size, s.size);
  }
}

// ============================================================
// HYPERSPACE VISUAL EFFECT (star-stretch)
// ============================================================
let hyperspaceEffect = 0;       // frames remaining for effect
let hyperspaceOriginX = 0;
let hyperspaceOriginY = 0;
const HYPERSPACE_DURATION = 20; // frames

function triggerHyperspaceEffect(fromX, fromY) {
  hyperspaceEffect = HYPERSPACE_DURATION;
  hyperspaceOriginX = fromX;
  hyperspaceOriginY = fromY;
}

function drawHyperspaceEffect() {
  if (hyperspaceEffect <= 0) return;
  const progress = 1 - (hyperspaceEffect / HYPERSPACE_DURATION);
  const alpha = 1 - progress;
  const stretchLen = 50 + progress * 300;

  ctx.save();
  ctx.globalAlpha = alpha * 0.8;
  for (let i = 0; i < 40; i++) {
    const angle = (i / 40) * Math.PI * 2 + progress * 0.5;
    const innerR = 10 + progress * 40;
    const x1 = hyperspaceOriginX + Math.cos(angle) * innerR;
    const y1 = hyperspaceOriginY + Math.sin(angle) * innerR;
    const x2 = hyperspaceOriginX + Math.cos(angle) * (innerR + stretchLen);
    const y2 = hyperspaceOriginY + Math.sin(angle) * (innerR + stretchLen);

    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    gradient.addColorStop(0, `rgba(180,200,255,${alpha})`);
    gradient.addColorStop(1, 'rgba(180,200,255,0)');
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
  ctx.restore();
  hyperspaceEffect--;
}

// ============================================================
// INPUT
// ============================================================
const keys = {};
const keyJustPressed = {};
window.addEventListener('keydown', e => {
  if (!keys[e.code]) keyJustPressed[e.code] = true;
  keys[e.code] = true;
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
    e.preventDefault();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

function consumeKey(code) {
  if (keyJustPressed[code]) { keyJustPressed[code] = false; return true; }
  return false;
}

// ============================================================
// TOUCH CONTROLS
// ============================================================
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

if (isTouchDevice) {
  document.body.classList.add('touch-visible', 'state-menu');

  const touchMap = {
    'btn-left':    'ArrowLeft',
    'btn-right':   'ArrowRight',
    'btn-thrust':  'ArrowUp',
    'btn-fire':    'Space',
  };

  for (const [btnId, keyCode] of Object.entries(touchMap)) {
    const el = document.getElementById(btnId);
    el.addEventListener('touchstart', e => {
      e.preventDefault();
      keys[keyCode] = true;
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }, { passive: false });
    el.addEventListener('touchend', e => {
      e.preventDefault();
      keys[keyCode] = false;
    }, { passive: false });
    el.addEventListener('touchcancel', e => {
      e.preventDefault();
      keys[keyCode] = false;
    }, { passive: false });
  }

  // Hyperspace â€” uses keyJustPressed
  const btnHyper = document.getElementById('btn-hyper');
  btnHyper.addEventListener('touchstart', e => {
    e.preventDefault();
    keys['KeyH'] = true;
    keyJustPressed['KeyH'] = true;
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }, { passive: false });
  btnHyper.addEventListener('touchend', e => { e.preventDefault(); keys['KeyH'] = false; }, { passive: false });
  btnHyper.addEventListener('touchcancel', e => { e.preventDefault(); keys['KeyH'] = false; }, { passive: false });

  // Menu buttons
  document.getElementById('btn-classic').addEventListener('touchstart', e => {
    e.preventDefault();
    keyJustPressed['Digit1'] = true;
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }, { passive: false });
  document.getElementById('btn-starwars').addEventListener('touchstart', e => {
    e.preventDefault();
    keyJustPressed['Digit2'] = true;
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }, { passive: false });

  // Game over continue button
  document.getElementById('btn-enter').addEventListener('touchstart', e => {
    e.preventDefault();
    keyJustPressed['Enter'] = true;
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }, { passive: false });
}

function updateTouchUI() {
  if (!isTouchDevice) return;
  document.body.classList.remove('state-menu', 'state-playing', 'state-gameover');
  document.body.classList.add('state-' + state);
  // Only show continue button after the game-over delay
  const btnEnter = document.getElementById('btn-enter');
  if (state === 'gameover' && gameOverTimer <= 0) {
    btnEnter.style.removeProperty('display');
  } else if (state === 'gameover') {
    btnEnter.style.display = 'none';
  }
}

// ============================================================
// GAME STATE
// ============================================================
let state = 'menu'; // menu, playing, gameover
let score = 0;
let highScore = parseInt(localStorage.getItem('asteroids_high') || '0');
let lives = 0;
let level = 0;
let ship = null;
let asteroids = [];
let bullets = [];
let particles = [];
let ufos = [];
let ufoBullets = [];
let respawnTimer = 0;
let gameOverTimer = 0;
let ufoTimer = 0;
let flickerTimer = 0;
let flickerOn = true;
let nextExtraLife = 10000;

// ============================================================
// ASTEROIDS
// ============================================================
const ASTEROID_SIZES = {
  large:  { radius: 40, speed: 1.0, score: 20 },
  medium: { radius: 20, speed: 1.8, score: 50 },
  small:  { radius: 10, speed: 2.8, score: 100 }
};

function createRandomRockShape() {
  const verts = [];
  const numVerts = 8 + Math.floor(Math.random() * 5);
  for (let i = 0; i < numVerts; i++) {
    const angle = (i / numVerts) * Math.PI * 2;
    const r = 0.7 + Math.random() * 0.3;
    verts.push([Math.cos(angle) * r, Math.sin(angle) * r]);
  }
  return verts;
}

function createAsteroid(x, y, size) {
  const sizeData = ASTEROID_SIZES[size];
  const angle = Math.random() * Math.PI * 2;
  const speed = sizeData.speed * (0.8 + Math.random() * 0.4);
  return {
    x, y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius: sizeData.radius,
    size,
    score: sizeData.score,
    rockShape: createRandomRockShape(),
    rotAngle: 0,
    rotSpeed: (Math.random() - 0.5) * 0.03
  };
}

function spawnAsteroidWave(count) {
  for (let i = 0; i < count; i++) {
    let x, y;
    do {
      x = Math.random() * WIDTH;
      y = Math.random() * HEIGHT;
    } while (ship && Math.hypot(x - ship.x, y - ship.y) < 200);
    asteroids.push(createAsteroid(x, y, 'large'));
  }
}

// ============================================================
// UFO
// ============================================================
function createUfo(type) {
  const scale = type === 'big' ? 1 : 0.5;
  const side = Math.random() < 0.5 ? 0 : WIDTH;
  return {
    x: side, y: Math.random() * HEIGHT,
    vx: (side === 0 ? 1 : -1) * (type === 'big' ? 2 : 3),
    vy: 0, type, scale,
    radius: type === 'big' ? 20 : 10,
    fireTimer: 0, dirChangeTimer: 0, soundTimer: 0
  };
}

// ============================================================
// BULLETS & PARTICLES
// ============================================================
function createBullet(x, y, angle, fromPlayer) {
  return { x, y, vx: Math.cos(angle) * 10, vy: Math.sin(angle) * 10, life: 50, fromPlayer };
}

function spawnExplosion(x, y, count, speed) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const s = Math.random() * speed;
    particles.push({
      x, y,
      vx: Math.cos(angle) * s, vy: Math.sin(angle) * s,
      life: 20 + Math.random() * 30, maxLife: 50
    });
  }
}

// ============================================================
// SHIP
// ============================================================
function createShip() {
  return {
    x: WIDTH / 2, y: HEIGHT / 2,
    angle: -Math.PI / 2,
    vx: 0, vy: 0,
    thrusting: false,
    radius: theme === 'starwars' ? 14 : 12,
    invulnerable: 120,
    dead: false,
    hyperspace: false,
    hyperspaceTimer: 0
  };
}

// ============================================================
// HELPERS
// ============================================================
function wrap(obj) {
  if (obj.x < 0) obj.x += WIDTH;
  if (obj.x > WIDTH) obj.x -= WIDTH;
  if (obj.y < 0) obj.y += HEIGHT;
  if (obj.y > HEIGHT) obj.y -= HEIGHT;
}
function circleCollision(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y) < a.radius + b.radius;
}

// ============================================================
// GAME LOGIC
// ============================================================
function startGame(selectedTheme) {
  theme = selectedTheme;
  state = 'playing';
  score = 0;
  lives = 3;
  level = 0;
  ship = createShip();
  asteroids = [];
  bullets = [];
  particles = [];
  ufos = [];
  ufoBullets = [];
  ufoTimer = 0;
  beatTimer = 0;
  beatInterval = 0.85;
  beatToggle = false;
  nextExtraLife = 10000;
  camX = 0;
  camY = 0;
  hyperspaceEffect = 0;
  nextLevel();
}

function nextLevel() {
  level++;
  spawnAsteroidWave(Math.min(2 + level * 2, 12));
}

function addScore(points) {
  const oldScore = score;
  score += points;
  if (score > highScore) highScore = score;
  if (score >= nextExtraLife && oldScore < nextExtraLife) {
    lives++;
    nextExtraLife += 10000;
    playSound('extra_life');
  }
}

let fireTimer = 0;

function updatePlaying(dt) {
  updateBeat(dt);

  if (ship && !ship.dead) {
    if (keys['ArrowLeft'] || keys['KeyA']) ship.angle -= 0.07;
    if (keys['ArrowRight'] || keys['KeyD']) ship.angle += 0.07;

    ship.thrusting = keys['ArrowUp'] || keys['KeyW'];
    if (ship.thrusting) {
      ship.vx += Math.cos(ship.angle) * 0.15;
      ship.vy += Math.sin(ship.angle) * 0.15;
      if (Math.random() < 0.3) playSound('thrust');
    }

    ship.vx *= 0.995;
    ship.vy *= 0.995;
    const spd = Math.hypot(ship.vx, ship.vy);
    if (spd > 8) { ship.vx = (ship.vx / spd) * 8; ship.vy = (ship.vy / spd) * 8; }

    ship.x += ship.vx;
    ship.y += ship.vy;

    // Update parallax camera
    camX += ship.vx;
    camY += ship.vy;

    wrap(ship);

    // Fire
    fireTimer -= dt;
    if ((keys['Space'] || keys['KeyF']) && fireTimer <= 0 && bullets.filter(b => b.fromPlayer).length < 4) {
      bullets.push(createBullet(
        ship.x + Math.cos(ship.angle) * 15,
        ship.y + Math.sin(ship.angle) * 15,
        ship.angle, true
      ));
      playSound('fire');
      fireTimer = 0.15;
    }

    // Hyperspace (Shift or H)
    if (consumeKey('ShiftLeft') || consumeKey('ShiftRight') || consumeKey('KeyH')) {
      const oldX = ship.x, oldY = ship.y;
      triggerHyperspaceEffect(oldX, oldY);
      playSound('hyperspace');
      ship.hyperspaceTimer = 15;
      ship.x = Math.random() * WIDTH;
      ship.y = Math.random() * HEIGHT;
      ship.vx = 0;
      ship.vy = 0;
      if (Math.random() < 0.125) {
        destroyShip();
      }
    }

    if (ship.hyperspaceTimer > 0) ship.hyperspaceTimer--;
    if (ship.invulnerable > 0) ship.invulnerable--;
  }

  // Respawn
  if (ship && ship.dead) {
    respawnTimer -= dt;
    if (respawnTimer <= 0) {
      if (lives > 0) {
        ship = createShip();
      } else {
        state = 'gameover';
        gameOverTimer = 3;
        localStorage.setItem('asteroids_high', highScore.toString());
      }
    }
  }

  // Bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx; b.y += b.vy; wrap(b);
    if (--b.life <= 0) bullets.splice(i, 1);
  }

  // Asteroids
  for (const a of asteroids) {
    a.x += a.vx; a.y += a.vy;
    a.rotAngle += a.rotSpeed;
    wrap(a);
  }

  // UFO logic
  ufoTimer -= dt;
  if (ufoTimer <= 0 && ufos.length === 0) {
    const type = (score > 10000 && Math.random() < 0.6) || (score > 40000) ? 'small' : 'big';
    ufos.push(createUfo(type));
    ufoTimer = 15 + Math.random() * 15;
    playSound(type === 'big' ? 'ufo_big' : 'ufo_small');
  }
  for (let i = ufos.length - 1; i >= 0; i--) {
    const u = ufos[i];
    u.x += u.vx; u.y += u.vy;
    u.dirChangeTimer -= dt;
    if (u.dirChangeTimer <= 0) { u.vy = (Math.random() - 0.5) * 3; u.dirChangeTimer = 1 + Math.random() * 2; }
    if (u.y < 0) u.y += HEIGHT; if (u.y > HEIGHT) u.y -= HEIGHT;
    if (u.x < -30 || u.x > WIDTH + 30) { ufos.splice(i, 1); continue; }
    u.fireTimer -= dt;
    if (u.fireTimer <= 0 && ship && !ship.dead) {
      let angle;
      if (u.type === 'small') { angle = Math.atan2(ship.y - u.y, ship.x - u.x) + (Math.random() - 0.5) * 0.2; }
      else { angle = Math.random() * Math.PI * 2; }
      ufoBullets.push(createBullet(u.x, u.y, angle, false));
      u.fireTimer = u.type === 'big' ? 1.5 : 1.0;
    }
    u.soundTimer -= dt;
    if (u.soundTimer <= 0) { playSound(u.type === 'big' ? 'ufo_big' : 'ufo_small'); u.soundTimer = 1.0; }
  }

  // UFO bullets
  for (let i = ufoBullets.length - 1; i >= 0; i--) {
    const b = ufoBullets[i];
    b.x += b.vx; b.y += b.vy; wrap(b);
    if (--b.life <= 0) ufoBullets.splice(i, 1);
  }

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    if (--p.life <= 0) particles.splice(i, 1);
  }

  // --- COLLISIONS ---
  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi]; if (!b.fromPlayer) continue;
    for (let ai = asteroids.length - 1; ai >= 0; ai--) {
      if (Math.hypot(b.x - asteroids[ai].x, b.y - asteroids[ai].y) < asteroids[ai].radius) {
        bullets.splice(bi, 1); destroyAsteroid(ai); break;
      }
    }
  }
  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi]; if (!b.fromPlayer) continue;
    for (let ui = ufos.length - 1; ui >= 0; ui--) {
      const u = ufos[ui];
      if (Math.hypot(b.x - u.x, b.y - u.y) < u.radius) {
        bullets.splice(bi, 1);
        addScore(u.type === 'big' ? 200 : 1000);
        spawnExplosion(u.x, u.y, 15, 3);
        playSound('explode_small');
        ufos.splice(ui, 1); break;
      }
    }
  }
  if (ship && !ship.dead && ship.invulnerable <= 0) {
    for (let ai = asteroids.length - 1; ai >= 0; ai--) {
      if (circleCollision(ship, asteroids[ai])) { destroyAsteroid(ai); destroyShip(); break; }
    }
  }
  if (ship && !ship.dead && ship.invulnerable <= 0) {
    for (let ui = ufos.length - 1; ui >= 0; ui--) {
      if (circleCollision(ship, ufos[ui])) { spawnExplosion(ufos[ui].x, ufos[ui].y, 15, 3); ufos.splice(ui, 1); destroyShip(); break; }
    }
  }
  if (ship && !ship.dead && ship.invulnerable <= 0) {
    for (let bi = ufoBullets.length - 1; bi >= 0; bi--) {
      if (Math.hypot(ufoBullets[bi].x - ship.x, ufoBullets[bi].y - ship.y) < ship.radius) { ufoBullets.splice(bi, 1); destroyShip(); break; }
    }
  }
  for (let bi = ufoBullets.length - 1; bi >= 0; bi--) {
    for (let ai = asteroids.length - 1; ai >= 0; ai--) {
      if (Math.hypot(ufoBullets[bi].x - asteroids[ai].x, ufoBullets[bi].y - asteroids[ai].y) < asteroids[ai].radius) {
        ufoBullets.splice(bi, 1); destroyAsteroid(ai); break;
      }
    }
  }

  if (asteroids.length === 0 && ufos.length === 0) nextLevel();
}

function destroyAsteroid(index) {
  const a = asteroids[index];
  addScore(a.score);
  spawnExplosion(a.x, a.y, 8, 2.5);
  if (a.size === 'large') {
    asteroids.push(createAsteroid(a.x, a.y, 'medium'));
    asteroids.push(createAsteroid(a.x, a.y, 'medium'));
    playSound('explode_big');
  } else if (a.size === 'medium') {
    asteroids.push(createAsteroid(a.x, a.y, 'small'));
    asteroids.push(createAsteroid(a.x, a.y, 'small'));
    playSound('explode_small');
  } else {
    playSound('explode_small');
  }
  asteroids.splice(index, 1);
}

function destroyShip() {
  if (!ship || ship.dead) return;
  ship.dead = true;
  lives--;
  spawnExplosion(ship.x, ship.y, 20, 4);
  playSound('explode_player');
  for (let i = 0; i < 4; i++) {
    const angle = Math.random() * Math.PI * 2;
    particles.push({
      x: ship.x, y: ship.y,
      vx: Math.cos(angle) * (1 + Math.random() * 2),
      vy: Math.sin(angle) * (1 + Math.random() * 2),
      life: 40 + Math.random() * 40, maxLife: 80,
      line: true, lineAngle: Math.random() * Math.PI * 2,
      lineLen: 5 + Math.random() * 10
    });
  }
  respawnTimer = 2.5;
}

// ============================================================
// RENDERING
// ============================================================
function drawPoly(points, x, y, angle, scale, close) {
  ctx.beginPath();
  for (let i = 0; i < points.length; i++) {
    const px = points[i][0] * scale;
    const py = points[i][1] * scale;
    const rx = px * Math.cos(angle) - py * Math.sin(angle) + x;
    const ry = px * Math.sin(angle) + py * Math.cos(angle) + y;
    if (i === 0) ctx.moveTo(rx, ry); else ctx.lineTo(rx, ry);
  }
  if (close !== false) ctx.closePath();
  ctx.stroke();
}

// Fill variant for engine glow
function fillPoly(points, x, y, angle, scale) {
  ctx.beginPath();
  for (let i = 0; i < points.length; i++) {
    const px = points[i][0] * scale;
    const py = points[i][1] * scale;
    const rx = px * Math.cos(angle) - py * Math.sin(angle) + x;
    const ry = px * Math.sin(angle) + py * Math.cos(angle) + y;
    if (i === 0) ctx.moveTo(rx, ry); else ctx.lineTo(rx, ry);
  }
  ctx.closePath();
  ctx.fill();
}

function drawShip(s) {
  if (s.dead) return;
  if (s.invulnerable > 0 && Math.floor(s.invulnerable / 4) % 2 === 0) return;

  const a = s.angle + Math.PI / 2;

  if (theme === 'starwars') {
    // --- MILLENNIUM FALCON ---
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    drawPoly(FALCON_SHIP, s.x, s.y, a, 1, true);

    // Corridor detail
    ctx.lineWidth = 0.8;
    drawPoly(FALCON_CORRIDOR, s.x, s.y, a, 1, true);

    // Radar dish
    const dx = FALCON_DISH.x * Math.cos(a) - FALCON_DISH.y * Math.sin(a) + s.x;
    const dy = FALCON_DISH.x * Math.sin(a) + FALCON_DISH.y * Math.cos(a) + s.y;
    ctx.lineWidth = 1.0;
    ctx.beginPath();
    ctx.arc(dx, dy, FALCON_DISH.r, 0, Math.PI * 2);
    ctx.stroke();

    // Blue engine glow when thrusting
    ctx.lineWidth = 1.5;
    if (s.thrusting) {
      const flicker = 0.7 + Math.random() * 0.5;
      const glowIntensity = 0.3 + Math.random() * 0.3;

      // Engine bar glow (across the rear)
      const engineBar = [[-7, 11.5], [7, 11.5]];
      ctx.save();
      ctx.shadowColor = '#4488ff';
      ctx.shadowBlur = 15 + Math.random() * 10;
      ctx.strokeStyle = `rgba(100,160,255,${glowIntensity + 0.4})`;
      ctx.lineWidth = 3;
      drawPoly(engineBar, s.x, s.y, a, 1, false);
      ctx.restore();

      // Outer glow flame shape
      const flameOuter = [
        [-7, 11], [-5, 11 + 8 * flicker], [0, 11 + 12 * flicker], [5, 11 + 8 * flicker], [7, 11]
      ];
      ctx.save();
      ctx.shadowColor = '#4488ff';
      ctx.shadowBlur = 20;
      ctx.fillStyle = `rgba(40,80,200,${glowIntensity * 0.4})`;
      fillPoly(flameOuter, s.x, s.y, a, 1);
      ctx.restore();

      // Inner bright core
      const flameInner = [
        [-4, 11], [-2, 11 + 5 * flicker], [0, 11 + 8 * flicker], [2, 11 + 5 * flicker], [4, 11]
      ];
      ctx.save();
      ctx.shadowColor = '#88bbff';
      ctx.shadowBlur = 10;
      ctx.fillStyle = `rgba(130,180,255,${glowIntensity * 0.7})`;
      fillPoly(flameInner, s.x, s.y, a, 1);
      ctx.restore();

      // Bright white hotspot
      const hotspot = [
        [-3, 11.5], [0, 11 + 4 * flicker], [3, 11.5]
      ];
      ctx.fillStyle = `rgba(200,220,255,${glowIntensity * 0.5})`;
      fillPoly(hotspot, s.x, s.y, a, 1);
    }
  } else {
    // --- CLASSIC TRIANGLE ---
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    drawPoly(CLASSIC_SHIP, s.x, s.y, a, 1, true);

    if (s.thrusting && Math.random() > 0.3) {
      const flicker = 0.8 + Math.random() * 0.4;
      ctx.strokeStyle = '#fff';
      drawPoly(CLASSIC_THRUST.map(p => [p[0], p[1] * flicker]), s.x, s.y, a, 1, false);
    }
  }
}

function drawTiePart(part, x, y, r, ang, close) {
  drawPoly(part.map(p => [p[0] * r, p[1] * r]), x, y, ang, 1, close);
}

function drawAsteroid(a) {
  ctx.strokeStyle = '#fff';
  const r = a.radius;
  const x = a.x;
  const y = a.y;
  const ang = a.rotAngle;

  if (theme === 'starwars') {
    // TIE Fighter
    ctx.lineWidth = 1.5;
    drawTiePart(TIE_COCKPIT, x, y, r, ang, true);
    ctx.lineWidth = 1.0;
    drawTiePart(TIE_VIEWPORT, x, y, r, ang, true);
    ctx.lineWidth = 1.5;
    drawTiePart(TIE_LEFT_WING, x, y, r, ang, true);
    drawTiePart(TIE_RIGHT_WING, x, y, r, ang, true);
    ctx.lineWidth = 1.2;
    drawTiePart(TIE_STRUT_L1, x, y, r, ang, false);
    drawTiePart(TIE_STRUT_L2, x, y, r, ang, false);
    drawTiePart(TIE_STRUT_R1, x, y, r, ang, false);
    drawTiePart(TIE_STRUT_R2, x, y, r, ang, false);
    ctx.lineWidth = 0.7;
    drawTiePart(TIE_LW_BRACE1, x, y, r, ang, false);
    drawTiePart(TIE_LW_BRACE2, x, y, r, ang, false);
    drawTiePart(TIE_LW_BRACE3, x, y, r, ang, false);
    drawTiePart(TIE_RW_BRACE1, x, y, r, ang, false);
    drawTiePart(TIE_RW_BRACE2, x, y, r, ang, false);
    drawTiePart(TIE_RW_BRACE3, x, y, r, ang, false);
  } else {
    // Classic rock
    ctx.lineWidth = 1.5;
    const pts = a.rockShape.map(p => [p[0] * r, p[1] * r]);
    drawPoly(pts, x, y, ang, 1, true);
  }
}

function drawUfo(u) {
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  const s = u.scale;
  const x = u.x;
  const y = u.y;
  const r = 20 * s;

  if (theme === 'starwars') {
    // Death Star
    // Main sphere outline
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.stroke();

    // Equatorial trench line
    ctx.beginPath();
    ctx.moveTo(x - r, y);
    ctx.lineTo(x + r, y);
    ctx.stroke();

    // Superlaser dish (concave circle in upper-left quadrant)
    const dishX = x - r * 0.25;
    const dishY = y - r * 0.35;
    const dishR = r * 0.3;
    ctx.beginPath();
    ctx.arc(dishX, dishY, dishR, 0, Math.PI * 2);
    ctx.stroke();
    // Dish focus point
    ctx.beginPath();
    ctx.arc(dishX, dishY, dishR * 0.15, 0, Math.PI * 2);
    ctx.fill();

    // Surface detail: upper latitude line
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    const latW1 = r * 0.92;
    ctx.moveTo(x - latW1, y - r * 0.2);
    ctx.quadraticCurveTo(x, y - r * 0.35, x + latW1, y - r * 0.2);
    ctx.stroke();

    // Lower latitude line
    ctx.beginPath();
    const latW2 = r * 0.92;
    ctx.moveTo(x - latW2, y + r * 0.25);
    ctx.quadraticCurveTo(x, y + r * 0.4, x + latW2, y + r * 0.25);
    ctx.stroke();

    // Vertical meridian line (subtle curve)
    ctx.beginPath();
    ctx.moveTo(x, y - r);
    ctx.quadraticCurveTo(x + r * 0.1, y, x, y + r);
    ctx.stroke();

  } else {
    // Classic flying saucer
    ctx.beginPath();
    ctx.moveTo(x - r, y);
    ctx.lineTo(x - 8 * s, y - 8 * s);
    ctx.lineTo(x + 8 * s, y - 8 * s);
    ctx.lineTo(x + r, y);
    ctx.closePath(); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x - r, y);
    ctx.lineTo(x - 8 * s, y + 8 * s);
    ctx.lineTo(x + 8 * s, y + 8 * s);
    ctx.lineTo(x + r, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x - 4 * s, y - 8 * s);
    ctx.lineTo(x - 2 * s, y - 14 * s);
    ctx.lineTo(x + 2 * s, y - 14 * s);
    ctx.lineTo(x + 4 * s, y - 8 * s);
    ctx.stroke();
  }
}

function drawBullet(b) {
  ctx.fillStyle = '#fff';
  ctx.fillRect(b.x - 1.5, b.y - 1.5, 3, 3);
}

function drawParticle(p) {
  const alpha = p.life / (p.maxLife || 50);
  ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
  ctx.fillStyle = `rgba(255,255,255,${alpha})`;
  if (p.line) {
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(p.x - Math.cos(p.lineAngle) * p.lineLen / 2, p.y - Math.sin(p.lineAngle) * p.lineLen / 2);
    ctx.lineTo(p.x + Math.cos(p.lineAngle) * p.lineLen / 2, p.y + Math.sin(p.lineAngle) * p.lineLen / 2);
    ctx.stroke();
  } else {
    ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
  }
}

function getShipShape() {
  return theme === 'starwars' ? FALCON_SHIP : CLASSIC_SHIP;
}

function drawHUD() {
  ctx.fillStyle = '#fff';
  ctx.font = '28px "Courier New", monospace';
  ctx.textAlign = 'left';
  ctx.fillText(score.toString().padStart(2, '0'), 40, 45);

  ctx.font = '18px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText(highScore.toString().padStart(2, '0'), WIDTH / 2, 30);

  for (let i = 0; i < lives; i++) {
    const lx = 45 + i * 25;
    const ly = 70;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.2;
    drawPoly(getShipShape(), lx, ly, 0, 0.7, true);
  }
}

function drawText(text, x, y, size) {
  ctx.fillStyle = '#fff';
  ctx.font = `${size}px "Courier New", monospace`;
  ctx.textAlign = 'center';
  ctx.fillText(text, x, y);
}

// ============================================================
// START MENU
// ============================================================
let menuAsteroids = [];
function initMenu() {
  menuAsteroids = [];
  // Use classic rock shapes for the menu background (theme-neutral)
  for (let i = 0; i < 8; i++) {
    menuAsteroids.push(createAsteroid(
      Math.random() * WIDTH,
      Math.random() * HEIGHT,
      ['large', 'medium', 'small'][Math.floor(Math.random() * 3)]
    ));
  }
}
initMenu();

function updateMenu(dt) {
  for (const a of menuAsteroids) {
    a.x += a.vx; a.y += a.vy;
    a.rotAngle += a.rotSpeed;
    wrap(a);
  }
  if (consumeKey('Digit1')) {
    startGame('classic');
  } else if (consumeKey('Digit2')) {
    startGame('starwars');
  }
}

function drawMenu() {
  // Draw floating rocks in classic style for the menu
  ctx.strokeStyle = '#fff';
  for (const a of menuAsteroids) {
    ctx.lineWidth = 1.5;
    const pts = a.rockShape.map(p => [p[0] * a.radius, p[1] * a.radius]);
    drawPoly(pts, a.x, a.y, a.rotAngle, 1, true);
  }

  // Title
  drawText('ASTEROIDS', WIDTH / 2, HEIGHT / 2 - 100, 64);
  drawText('Made by John Fulton', WIDTH / 2, HEIGHT / 2 - 65, 18);

  // High score
  ctx.font = '18px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.fillText('HIGH SCORE  ' + highScore.toString().padStart(2, '0'), WIDTH / 2, 30);

  // Mode selection
  drawText('SELECT MODE', WIDTH / 2, HEIGHT / 2 + 5, 22);

  if (!isTouchDevice && flickerOn) {
    drawText('PRESS 1 FOR CLASSIC 1979', WIDTH / 2, HEIGHT / 2 + 55, 20);
    drawText('PRESS 2 FOR STAR WARS', WIDTH / 2, HEIGHT / 2 + 90, 20);
  }

  // Draw a preview ship for each mode
  // Classic triangle on the left
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  drawPoly(CLASSIC_SHIP, WIDTH / 2 - 180, HEIGHT / 2 + 72, 0, 1.2, true);

  // Falcon on the right
  drawPoly(FALCON_SHIP, WIDTH / 2 + 160, HEIGHT / 2 + 72, 0, 1.2, true);

  if (!isTouchDevice) {
    // Controls hint (keyboard only)
    drawText('CONTROLS:', WIDTH / 2, HEIGHT / 2 + 155, 16);
    drawText('ARROWS = ROTATE/THRUST    SPACE = FIRE    H = HYPERSPACE', WIDTH / 2, HEIGHT / 2 + 180, 14);
  }
}

// ============================================================
// GAME OVER
// ============================================================
function updateGameOver(dt) {
  gameOverTimer -= dt;
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    if (--p.life <= 0) particles.splice(i, 1);
  }
  for (const a of asteroids) {
    a.x += a.vx; a.y += a.vy;
    a.rotAngle += a.rotSpeed;
    wrap(a);
  }
  // Return to start menu
  if (gameOverTimer <= 0 && (consumeKey('Enter') || consumeKey('Space'))) {
    state = 'menu';
    initMenu();
  }
}

function drawGameOver() {
  for (const a of asteroids) drawAsteroid(a);
  for (const p of particles) drawParticle(p);
  drawHUD();
  drawText('GAME OVER', WIDTH / 2, HEIGHT / 2, 48);
  if (gameOverTimer <= 0 && flickerOn && !isTouchDevice) {
    drawText('PRESS ENTER TO CONTINUE', WIDTH / 2, HEIGHT / 2 + 50, 18);
  }
}

// ============================================================
// MAIN LOOP
// ============================================================
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, WIDTH, HEIGHT);

  flickerTimer += dt;
  if (flickerTimer > 0.5) { flickerTimer -= 0.5; flickerOn = !flickerOn; }

  updateTouchUI();

  switch (state) {
    case 'menu':
      drawStars();
      updateMenu(dt);
      drawMenu();
      break;

    case 'playing':
      updatePlaying(dt);
      drawStars();
      for (const a of asteroids) drawAsteroid(a);
      for (const b of bullets) drawBullet(b);
      for (const b of ufoBullets) drawBullet(b);
      for (const u of ufos) drawUfo(u);
      for (const p of particles) drawParticle(p);
      if (ship) drawShip(ship);
      drawHyperspaceEffect();
      drawHUD();
      break;

    case 'gameover':
      drawStars();
      updateGameOver(dt);
      drawGameOver();
      break;
  }

  // Clear just-pressed keys at end of frame
  for (const key in keyJustPressed) keyJustPressed[key] = false;

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
